This release provides many incremental improvements to 3.0 while introducing two major new features.


<h4>OpenAPI Support (experimental)</h4>

Experimental support for OpenAPI is now available as extension to the Crnk generator. It will generate
an OpenAPI schema out of any Crnk endpoint by inspecting the implementation and drive a schema. An
example setup looks like:

<pre class="prettyprint">
buildscript {
    dependencies {
        classpath "io.crnk:crnk-gen-gradle:${version}"
    }
}

apply plugin: 'crnk-gen'
    crnkGen {
        runtime {
            configuration = 'openapiGenRuntime'
        }

        // fork generation into new process to have clean environment
        forked = true

        // specify the package to look for resources
        resourcePackages = ['io.crnk.test']

        openapi {
            // enable OpenAPI generation within Gradle plugin
            enabled = true

            // specify name of openapi template in the build dir to merge onto
            templateName = "openapi-template.yml"

            // specify name of API to display in the generated OpenAPI file
            projectName = "Generated Title"

            // specify version of the API to display in the generated OpenAPI file
            projectVersion = "0.1.0"

            // specify name of openapi template in the build dir to merge onto
            projectDescription = "A generated description of the API."

            // specify location of generated sources
            genDir = file('src/resources')
        }
    }
}
crnkGen.init()
</pre>

Fore more information see <a href="http://www.crnk.io/releases/latest/documentation/#_openapi">here</a>.
Have a look at the GitHub tickets for the future roadmap.


<h4>Bulk Repositories (experimental)</h4>

There is a new experimental <i>BulkResourceRepository</i> that closely resembles ResourceRepository but
takes multiple resources as arguments. This to allow the repository to optimize the bulk mutation of
multiple entities.

Currently only POST is implemented, not PATCH and DELETE yet! More information can be
found <a href="http://www.crnk.io/releases/latest/documentation/#_bulkresourcerepository">here</a>.
In future releases this will be aligned with support for the upcoming JSON:API 1.1 specification.


<h4>TestKit</h4>

There is a new project <i>io.crnk:crnk-testkit</i> to facilitate testing of JSON:API based endpoints.
As first contribution there is a <i>RandomWalkLinkChecker</i>:

<pre class="prettyprint">
CrnkClient client = ...
HttpAdapter httpAdapter = client.getHttpAdapter();

RandomWalkLinkChecker linkChecker = new RandomWalkLinkChecker(httpAdapter);
linkChecker.setWalkLength(100);
linkChecker.addStartUrl(...)

linkChecker.performCheck();
</pre>

It performs a random walk on an API endpoint by following the links as specified by JSON:API. It
will verify that each links provides a valid 2xx response code. By having a sufficiently long walk,
it will ensure that any GET request can be served with high probability and can proof useful to detect
corner cases not yet covered by testing. Further enhancements are planned in the future.

More information is available <a href="http://www.crnk.io/releases/latest/documentation/#_testkit">here</a>.


<h4>Minor Improvements</h4>

<ul>
    <li>There is a new documentation section about in-memory repositories for how to make use of
        in for small data sets, testing and mocking: See <a
                href="http://www.crnk.io/releases/latest/documentation/#_in_memory">here</a>.
    </li>
    <li>
        CrnkClient verifies the resourceClass of passed QuerySpec objects to ensure they match with the invoked
        repositories. <b>Watch out for this change</b>, because it was easy to get this wrong and may never got noticed.
        It makes no difference for empty QuerySpec. Otherwise, it may ignored filtering, sorting and paging requests
        (because they referred to another resource class).
    </li>
    <li>Attributes and relationships can no longer be named &quot;meta&quot; and &quot;links&quot; to
        have a clear distinction to the JSON:API data structures.
    </li>
    <li>Sorting for JPA entities with @EmbeddedId has been improved (<a
            href="https://github.com/crnk-project/crnk-framework/issues/603">603</a>).
    </li>
    <li>
        Self urls can now be written manually by returning link objects implementing SelfLinksInformation.
    </li>
    <li>
        @JsonProperty support is fixed to allow to rename nested resource relationships.
    </li>
    <li>
        CrnkClient makes use of nested URLs for nested resources, e.g. /api/project/{projectId}/tasks/{taskId}.
    </li>
    <li>@JsonApiField.sortable and @JsonApiField.filterable allow to disable sorting and filtering for a field.
        A 400 BAD_REQUEST will be returned in case of a violation has been detected. See
        <a href="http://www.crnk.io/releases/latest/documentation/#_jsonapifield">here</a>.
    </li>
    <li>
        HomeModule will add links to JSON:API responses if there are resources with overlapping paths, such as
        <i>/api/tasks</i> and <i>/api/tasks/history</i>.
    </li>
    <li>HomeModule supports the same exception response format as any other JSON:API response.</li>
    <li>An example for @JsonAnyGetter and @JsonAnySetter has been added to the example application to showcase
        the use of more dynamic resources, see
        <a href="https://github.com/crnk-project/crnk-example/blob/master/crnk-example-service/src/main/java/io/crnk/example/service/model/PersonEntity.java">PersonEntity</a>
    </li>
    <li>
        DataRoom filter logging has been refined to log with WARN.
    </li>
    <li>
        JPA repositories are aware of @JsonApiRelationId annotations and optimize sorting and filtering accordingly.
    </li>
    <li>
        JPA repositories will do a LEFT join when sorting on a column on a related entity.
    </li>
    <li>Nested repositories can now span multiple levels, such as <i>/api/project/{projectId}/tasks/{taskId}/items/{itemId}</i>
    </li>
    <li>
        Repositories from CrnkClient make use of <i>@JsonApiExposed(false)</i>. It allows there
        use on the server-side to consume other services without exposing the repositories again.
        When returning resources obtained from such a repository, they will maintain proper linking
        to the original service as long a the resources carry a links object implementing
        SelfLinksInformation. For an example see
        <a href="https://github.com/crnk-project/crnk-framework/tree/master/crnk-integration-examples/spring-boot-microservice-example">spring-boot-microservice-example</a>
    </li>
    <li>
        CrnkClient can be configured with a custom ObjectMapper using <i>CrnkClient.setObjectMapper(...)</i>.
    </li>
    <li>
        ResourceIdentifier can be used together with @JsonApiRelationId do not only hold the ID, but also
        the type of the relationship. Useful when inheritance is involved to directly address the proper subtype.
    </li>
    <li>
        <i>ResourceTypeHolder</i> interfaces allows a resource to hold its resource type. This can proof
        useful in more dynamic settings where inheritance is involved and a repository likes to manipulate
        the type of its resources without having to work with strongly-typed resource classes. Together
        with @JsonAnyGetter and @JsonAnySetter it allows for highly dynamic, non-compile-time repository
        implementations similar to the direct use of the Resource class. For information is available
        in the documentation.
    </li>
</ul>

