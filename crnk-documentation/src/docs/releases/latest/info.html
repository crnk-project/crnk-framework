

<h4>Classpath scanning for Typescript generator</h4>

The Typescript generator used to need a running application to extract information about the set
of resources and repositories. This remains the best and only way to reliably extract all informations
out of a Crnk-based application. However, due to this architecture, generation is also prone to fail
due to misconfiguration of the application. For this reason, this release introduces an new, alternative
mechanism where
the classpath can be scanned for @JsonApiResource-annotated classes and repository interface
definitions extending ResourceRepositoryV2. The benefit is a simpler setup at the cost of potentially
missing out on non-standard repositories that are not backed by a @JsonApiResource annotation.
In Gradle this then looks like:

<pre class="prettyprint">
typescriptGen{
  resourcePackages = ['Ã®o.crnk.example']
  ...
}
</pre>



<h4>@JpaResource annotation deprecated</h4>

@JpaResource rather than @JsonApiResource has historically been necessary to modify the naming
of Entity-based resources. This is no longer necessary and @JsonApiResource can be used together
with classes annotated with @Entity.


<h4>Historic Activiti repositories</h4>

There is initial experimental support for historic resource repositories of Activiti tasks and processes.

<pre class="prettyprint">
ActivitiModuleConfig config = new ActivitiModuleConfig();
ProcessInstanceConfig processConfig = config.addProcessInstance(ScheduleApprovalProcessInstance.class);
processConfig.historic(HistoricScheduleApprovalProcessInstance.class);

TaskRepositoryConfig taskConfig = config.addTask(ApproveTask.class);
taskConfig.historic(HistoricApproveTask.class);
taskConfig.filterBy("description", ENFORCED_DESCRIPTION);
return ActivitiModule.create(processEngine, config);
</pre>


<h4>Simplified customizations of Criteria-based crnk-jpa repositories</h4>

There is a new interface JpaCriteriaRepositoryFilter and base class JpaCriteriaRepositoryFilterBase that allow
easy customization of CriteriaQuery objects. The interfaces are a specialization of JpaRepositoryFilter
and can be used in the same manner by registering it to the JpaModuleConfig.

<h4>PathSpec within QuerySpec</h4>

All the QuerySpec-related objects like FilterSpec and SortSpec now hold the attribute path
as PathSpec. PathSpec facilitate working with paths compared to the previous List&lt;String&gt; solution.
All the previous API remains unchanged and supported (no deprecations).

<h4>QuerySpecVisitor</h4>

The new QuerySpecVisitor and QuerySpecVisitorBase classes allow to visit
a QuerySpec by calling QuerySpec.accept(QuerySpecVisitor). Visitors can be used, for example,
to easily modify attribute paths within a QuerySpc.

<h4>InMemoryEvaluator</h4>

InMemoryEvaluator gained a new constructor that takes a ResourceRegistry. This allows the use of resource information
when accessing resources. This allows its use with more customized resources and relationships, like the use of
@JsonApiRelationId and custom ResourceFieldAccessors instead of just basic plain Java beans. Note that QuerySpec.apply(...)
does not have access to a ResourceRegistry and, consequently, continues to use the traditional behavior.
