:basedir: ../../../..
:clientdir: {basedir}/crnk-client


anchor:client[]

# Client

There is a client implementation for Java and Android projects to allow
communicating with JSON-API compliant servers.


## Setup

The basic setup is:

[source]
----
  CrnkClient client = new CrnkClient("http://localhost:8080/api");
----

Four underlying http client libraries are supported.
Add one of those library to the classpath and Crnk will pick it up automatically.
A custom `HttpAdapter` can also set passed to `CrnkClient.setHttpAdapter(...)`.

* https://github.com/square/okhttp[OkHttp]
 that is popular for Java and Android development. Implemented by
 `io.crnk.client.http.okhttp.OkHttpAdapter`.

* https://hc.apache.org/httpcomponents-client-ga/index.html[Apache Http Client]
  implemented by `io.crnk.client.http.apache.HttpClientAdapter`.

* `RestTemplate` from Spring provides a Spring abstraction of other HTTP libraries.
  Spring application benefit from using this over the underlying native implementation to share
  the setup configuration setup. It is used by default if the presence of Spring is detected.
  Implemented by `io.crnk.spring.client.RestTemplateAdapter`.

* `InMemoryHttpAdapter` to directly connect a client to a server without a TCP transport layer
  or HTTP server. This *implementation is well suited for unit testing* as no server must be setup, making
  unit tests simpler and faster to write, execute and debug. In contrast to invoking a repository directly
  on the server, `InMemoryHttpAdapter` request still pass through the entire Crnk serialization layer
  and are processed like any other HTTP request.
+
[source]
----
  String url = "http://localhost:8080/api";
  CrnkClient client = new CrnkClient(url);
  client.setHttpAdapter(new InMemoryHttpAdapter(crnkBoot, url));
----


WARNING: For Spring a *reasonable HTTP client implementation must underlie `RestTemplate`*
in order for `crnk-client` to work properly. For example, the default Java implementation does not
support the `PATCH` method and as such no resources can be updated.
To explicitly set HTTP implementation use:

[source]
----
  RestTemplateAdapter adapter = (RestTemplateAdapter) client.getHttpAdapter();
  RestTemplate template = adapter.getImplementation();
  template.setRequestFactory(new OkHttp3ClientHttpRequestFactory());
----

or

[source]
----
  client.setHttpAdapter(new RestTemplateAdapter(customRestTemplate));
----


## Usage

The client has three main methods:

* `CrnkClient#getRepositoryForInterface(Class)` to obtain a resource repository stub from an existing repository interface.
* `CrnkClient#getRepositoryForType(Class)` to obtain a generic resource repository stub from the provided resource type.
* `CrnkClient#getRepositoryForType(Class, Class)` to obtain a generic relationship repository stub from the provided source and target resource types.

The interface of the repositories is as same as defined in `Repositories`_ section.

An example of the usage:

[source]
----
  CrnkClient client = new CrnkClient("http://localhost:8080/api");
  ResourceRepository<Task, Long> taskRepo = client.getRepositoryForType(Task.class);
  List<Task> tasks = taskRepo.findAll(new QuerySpec(Task.class));
----

Have a look at, for example, the QuerySpecClientTest to see more examples of how it is used.

## URL handling

Crnk client and server share the URL handling. `QuerySpecUrlMapper` performs the mapping of HTTP request parameters to QuerySpec.
For more information see <<urlmapper,url mapping>>.

## Modules

`CrnkClient` can be extended by modules:

[source]
----
  CrnkClient client = new CrnkClient("http://localhost:8080/api");
  client.addModule(ValidationModule.create());
----

Typical use cases include:

- adding exception mappers
- registering new types of resources (like JPA entities by the `JpaModule`)
- intercepting requests for monitoring
- adding security tokens to requests
- setup the `PlainJsonFormatModule`

Many modules allow a registration both on server and client side.
The client part then typically makes use of a subset of the server features, like
exception mappers and resource registrations.

There is a mechanism to discover and register client modules automatically:

[source]
----
  CrnkClient client = new CrnkClient("http://localhost:8080/api");
  client.findModules();
----

`findModules` makes use of `java.util.ServiceLoader` and looks up
for `ClientModuleFactory`. `JpaModule`, `ValidationModule`,
`MetaModule`, `SecurityModule` implement such a service registration.
In contrast, `BraveModule` needs a Brave instance and does not yet
allow a fully automated setup.


## Type-Safety

It is possible to work with `CrnkClient` in a fully type-safe manner.

In a first step an interface for a repository is defined:

[source]
.ScheduleRepository.java
----
include::../../../../crnk-test/src/main/java/io/crnk/test/mock/repository/ScheduleRepository.java[tags=doc]
----

And then it can be used like:

[source]
.QuerySpecClientTest.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/suite/RepositoryAccessClientTest.java[tags=interfaceAccess]
----


anchor:client_jaxrs[]



## HTTP customization

`CrnkClient#getHttpAdapter()` gives access to the `HttpAdapter`.
There are two ways to customize HTTP requests:

- A `HttpAdapterListener` can be added with `addListener`
  to  `HttpAdapter`. `HttpAdapterListener`  allows to intercept both requests and responses and perform changes.
- The `HttpAdapter` interface can be cast to used implementation, which in turn gives access to the native
  builder/listener mechanisms to perform any kind of advanced customization.

Typical use cases to customize the HTTP requests and responses are:

- add custom request headers (security, tracing, etc.)
- collect statistics
- ...

Some examples:

- https://github.com/crnk-project/crnk-framework/blob/master/crnk-monitor/crnk-monitor-brave4/src/main/java/io/crnk/monitor/brave/BraveClientModule.java[crnk-monitor-brave4] for
 an advanced example.
- https://stackoverflow.com/questions/32196424/how-to-add-headers-to-okhttp-request-interceptor?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa[How to add
   headers to OkHttp request interceptor].




## JAX-RS interoperability

The interface stubs from the previous section can also be used to make calls to JAX-RS. For example, the
`ScheduleRepository` can be complemented with a JAX-RS annotation:

[source]
.ScheduleRepository.java
----
include::../../../../crnk-test/src/main/java/io/crnk/test/mock/repository/ScheduleRepository.java[tags=annotation]
----

and further JAX-RS services can be added:

[source]
.ScheduleRepository.java
----
include::../../../../crnk-test/src/main/java/io/crnk/test/mock/repository/ScheduleRepository.java[tags=services]
----

To make this work a dependency to `org.glassfish.jersey.ext:jersey-proxy-client` must be added and `JerseyActionStubFactory`
registered with `CrnkClient`:

[source]
.AbstractClientTest.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/AbstractClientTest.java[tags=jerseyStubFactory]
----

Then a client can make use the Crnk stubs and it will transparently switch between JSON-API and JAX-RS calls:

[source]
.JsonApiActionResponseTest.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/action/JsonApiActionResponseTest.java[tags=invokeService]
----

WARNING: Due to limited configurability of the Jersey Proxies it is currently not possible to reuse the same HTTP connections
for both types of calls. We attempt to address that in the future. Be aware of this when you, for example, add further
request headers (like security), as it has to be done in two places (unfortunately).

