
# Module Development

Crnk has a module API that allows to extend the core functionality by third-party contributions.
The mentioned JPA module in the next section is an example for that. The API is similar in spirit
to the one of the `https://github.com/FasterXML/jackson`. The main interface is `Module` with
a default implementation provided by `SimpleModule`. A module has access to a `ModuleContext`
that allows to register all kinds of extensions like new `ResourceInformationBuilder`,
`ResourceLookup`, `Filter`, `ExceptionMapper` and Jackson modules. It also gives access to the
`ResourceRegistry` holding information about all the repositories registered to crnk.
The `JpaModule` in `crnk-jpa` provides a good, more advanced example of using the
module API.



## Request Filtering

Crnk provides three different, complementing mechanisms to hook into the request processing.

The `DocumentFilter` interface allows to intercept incoming requests and do
any kind of validation, changes, monitoring, transaction handling, etc. `DocumentFilter` can be
hooked into Crnk by setting up a module and registering the filter to the
`ModuleContext`. Not that for every request, this interface is called exactly once.

A request may span multiple repository accesses. To intercept the actual repository requests,
implement the `RepositoryFilter` interface. `RepositoryFilter` has a number of methods
that allow two intercept the repository request at different stages. Like `Filter` it can be
hooked into Crnk by setting up a module and registering the filter to the
`ModuleContext`.

Similar to `RepositoryFilter` it is possible to decorate a repository with another repository
implementing the same Crnk repository interfaces. The decorated repository instead of
the actual repository will get called and it is up to the decorated repository of how to proceed
with the request, usually by calling the actual repository. `RepositoryDecoratorFactory`
can be registered with `ModuleContext.addRepositoryDecoratorFactory`. The factory gets
notified about every repository registration and is then free do decorate it or not.


## Resource Filtering

`ResourceFilter` allows to restrict access to resources and fields. To methods `filterResource` and
`filterField` can be implemented for this purpose. Both return a `FilterBehavior` which allows to
distinguish between `NONE`, `IGNORE` and `FORBIDDEN`. For example, a field like a
lock count can make use of `IGNORE` in order to be ignored for POST and PATCH requests (the current value
on the server is left untouched). While access to an unauthorized resource or
field results in a forbidden error with `FORBIDDEN`.

The `SecurityModule` makes use of `ResourceFilter` to perform access control.
`SecurityResourceFilter` in 'crnk-security` gives an example how it is used. The `MetaModule` and
`HomeModule` make use of `FilterBehaviorDirectory` obtained with `ModuleContext.getFilterBehaviorDirectory(...)` to
query those `ResourceFilter` and only display information about resources and fields accessible in the context
of the current re quest. The `FilterBehaviorDirectory` makes use of per-request caching as the information
may be accessed repeatedly for a request.


## Integrate third-party data stores

The core of Crnk is quite flexible when it comes to implementing repositories. As such, it is
not mandatory to make use of the Crnk annotations and conventions. Instead, it is also
(likely) possible to integrate an existing data store setup like JPA, JDBC, ElasticSearch, etc.
into Crnk. For this purpose a module can provide custom implementations of
`ResourceInformationBuilder` and `RepositoryInformationBuilder` trough
`ModuleContext.addResourceInformationBuilder` and `ModuleContext.addRepositoryInformationBuilder`.
For example, the JpaModule of  `crnk-jpa` makes use of that to read JPA instead of Crnk annotations.
Such a module can then register additional (usually dynamic) repositories with
`ModuleContext.addRepository`.


## Implement a custom discovery mechanism

Crnk comes with out-of-the-box support for Spring and CDI. Both of them implement
`ServiceDiscovery`. You may provide your own implementation which can be hooked into the
various Crnk integrations, like the CrnkFeature. Modules have access to that
`ServiceDiscovery` trough the `ModuleContext`.


## Let a module hook into the Crnk HTTP client implementation

Modules for the Crnk client can additionally implement `HttpAdapterAware`. It gives
the module access to the underlying HTTP client implementation and allows arbitrary
customizations of it. Have a look at the Crnk client documentation for more information.

## Implement a custom integration

Adding a new integration has become quite simple in recent times.
Have a look at `crnk-servlet` and `crnk-rs`. Most functionality
necessary is already be provided by `crnk-core`. The steps include:

- implement `HttpRequestContextBase`.
- instantiate `CrnkBoot` to setup crnk.
- get the `RequestDispatcher` from `CrnkBoot`.
- invoke the `RequestDispatcher` for each incoming request with the implemented
  `HttpRequestContextBase`.
- you may want to further implement `SecurityProvider`, `TransactionRunner`
  and `PropertiesProvider` to interface with that particular systems.


## Create repositories at runtime

Repositories are usually created at compile-time, either by making use of the various annotations or a module
such as the ´JpaModule´. However, the module API also allows the creation of repositories at runtime.
There are two complementary mechanisms in place to achieve this and outlined in the next two sections.

NOTE: this feature is in incubation, more refinements are expected in upcoming releases.

### Implementing repositories dynamically at runtime

There are different possibilities to implement a repository at runtime:

- Create a matching resource class at runtime with a library like http://bytebuddy.net/#/ to follow the same
  pattern as for any compile-time repository.
- Make use of the `Resource` class. It is the generic JSON API resource presentation within the Crnk engine.
- Make use of an arbitrary dynamic object like a `java.util.Map` and provide a `ResourceFieldAccessor` for
  each `ResourceField` to specify how to read and write attributes (see below for `ResourceField` examples).

In the following example we make use of the second option:

[source]
.DynamicResourceRepository.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicResourceRepository.java[tags=docs1]
...
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicResourceRepository.java[tags=docs2]
----

This new repository can be registered to Crnk with a module:

[source]
.DynamicModule
----
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicModule.java[tags=docs]
----

A new `RegistryEntry` is created and registered with Crnk. It provides information about:

- the resource and all its fields.
- the repositories and instances thereof.

Have a look at the complete example
in https://github.com/crnk-project/crnk-framework/tree/master/crnk-client/src/test/java/io/crnk/client/dynamic[`crnk-client`].
There is a further example test case and relationship repository.

### Registering repositories at runtime

There are two possibilities to register a new repository at runtime:

- by using a `Module` and invoking `ModuleContext.addRegistryEntry` as done in the previous section.
- by implementing a `ResourceRegistryPart` and invoking `ModuleContext.addResourceRegistry`.

The first is well suited if there is a predefined set of repositories that need to be registered
(like a fixed set of JPA entities in the `JpaModule`). The later is suited for fully dynamic use cases where
the set of repositories can change over time (like tables in a database or tasks in an activiti instance). In this
case the repositories no longer need registration. Instead the custom `ResourceRegistryPart` implementation always
provides an up-to-date set of repositories that is used by the Crnk engine.

An example can be found at
https://github.com/crnk-project/crnk-framework/tree/master/crnk-core/src/test/java/io/crnk/core/engine/registry/CustomResourceRegistryTest.java[CustomResourceRegistryTest.java]



## Discovery of Modules by CrnkClient

If a module does not need configuration, it can provide a `ClientModuleFactory`
implementation and register it to the `java.util.ServiceLoader` by adding a
'META-INF/services/io.crnk.client.module.ClientModuleFactory` file
with the implementation class name. This lets `CrnkClient` discover
the module automatically when calling `CrnkClient.findModules()`.
An example looks like:

[source]
.ValidationClientModuleFactory
----
include::../../../../crnk-validation/src/main/java/io/crnk/validation/internal/ValidationClientModuleFactory.java[]
----

and

[source]
.META-INF/services/io.crnk.client.module.ClientModuleFactory
----
include::../../../../crnk-validation/src/main/resources/META-INF/services/io.crnk.client.module.ClientModuleFactory[]
----



