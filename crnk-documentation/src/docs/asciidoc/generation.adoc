anchor:generation[]

# Generation

Crnk allows the generation of Typescript stubs for type-safe, client-side web development. Contributions for other
languages like iOS would be very welcomed.

## Typescript

The Typescript generator allows the generation of:

- interfaces for resources and related objects (like nested objects and enumeration types).
- interfaces for result documents (i.e. resources and any linking and meta information).
- interfaces for links information.
- interfaces for meta information.
- methods to create empty object instances.
- QueryDSL-like expression classes (see <expressions>)

Currently the generator targets the http://github.com/abdulhaq-e/ngrx-json-api[ngrx-json-api] library.
Support for other libraries/formats would be straightforward to add, contributions welcomed. A generated resource looks
like:

[source]
----
include::../../../../crnk-gen-typescript/src/test/resources/expected_schedule_without_expressions.ts[]
----

For an example have a look at the Crnk example application, see https://github.com/crnk-project/crnk-example[crnk-project/crnk-example].


### Setup

Internally the generator has to make use of the running application to gather the necessary information for generation. This
approach not only supports the typical, manual implement resources and repositories manually, but also
the ones obtained through third-party modules such the JPA entities exposed by the JPA module. There are different
possibilities to do that. https://github.com/crnk-project/crnk-framework/blob/master/crnk-client-angular-ngrx/build
.gradle[crnk-client-angular-ngrx]
does such a setup manually in Gradle. Alternatively, there is a Gradle plugin taking care of the generator setup. It makes use
of the JUnit to get
the application to a running state at built-time. Currently supported are CDI and Spring-based applications.

Such a setup may look like:

[source]
----
buildscript {
	dependencies {
		classpath "io.crnk:crnk-gen-typescript:${version}"
		classpath "com.moowork.gradle:gradle-node-plugin:1.1.1"
	}
}

node {
	version = '6.9.1'
	download = true
	distBaseUrl = "${ADN_NODEJS_MIRROR_BASE_URL}/dist"
}

apply plugin: 'crnk-gen-typescript'

configurations {
	typescriptGenRuntime
}

dependencies {
	typescriptGenRuntime project(':project-to-generate-from')
}

typescriptGen{

	runtime {
		configuration = 'typescriptGenRuntime'
        spring {
        	profile = 'test'
        	configuration = 'ch.adnovum.arch.demo.management.service.ManagementApplication'
        	initializerMethod = 'someInitMethod'
        	defaultProperties['someKey'] = 'someValue'
        }
	}

	npm {
		// map given Java package to a subdirectory of genDir
		directoryMapping['io.myapp.types'] = '/types'

		// map a given package to a third-party library
		packageMapping['io.other.app'] = '@other/app'
	}

	// include/exclude elements from generation
	includes = ['resources.task']
	excludes = ['resources.project']

	// fork generation into new process to have clean environment
	forked = true

	// generate QueryDSL-like expression objects
	generateExpressions = true

	// specify location of generated sources
	genDir = ...

}
typescriptGen.init()


----

Applying `crnk-gen-typescript` results in a new `generateTypescript` task. Consumers may want to add
that task to `assemble` as dependency. The sources are then generated to `genDir` as specified.

The plugin is in need for a running application to extract the set of available resources. The `runtime` section provides
a number of possibilities how this can be achieved. Typically the simplest way to have a running application is to
run in the same manner as for testing. This can be achieved, for example, by replicating the classpath, configuration,
environment, Spring profiles, etc. Currently supported are Spring and CDI to achieve this. Please open up a ticket
if you desire to work in another environment. There are a number of properties to do that:

- `runtime.configuration` sets the Gradle configuration to use to construct a classpath. In the given example
   `typescriptGenRuntime` is used. You may also use `compile` or anything else.
- for CDI it will work out-of-the-box if Weld is found on the classpath.
- for Spring properties allow to set the Spring profile, default properties and configuration
  class to use. Optionally an `initializerMethod` can be specified that is invoked before the
  Spring application to perform further customization.

The plugin strives for the generated sources to closely resemble the REST layer as possible.
As a consequence it makes use of the resource types and json names rather than Java names for the generated sources.
Important to know is that each type is assigned a meta id: for resources it is `resources.<resourceType>` and
for all other objects the Java package name. Based on the meta id, there are a number of possibilities to influence
the generation:

- `includes` and `excludes` allow to include and exclude resources from generation based on their meta id.
- `directoryMapping` allows to specify into which (sub)directory types are generated into. By default
   will be generated into the root directory.
- `packageMapping` allows to specify that a given type is obtained from a third-party library.

The plugin allows various further customization options:

- `generateExpressions` specifies whether QueryDSL like classes should be generated (`false` as default).
- by default the generation takes place in a forked process. Since the generator typically
  runs the application and that may not properly cleanup, it is recommended to let the
  generator fork a new process to avoid resource leakage in Gradle daemons and
  have more stable builds.


### Error Handling

Since the Typescript generator internally launches the application to extract information about its resources, the
generator is in need of a consistent application/Crnk setup. For example, every resource must have a match
repository serving it. Otherwise
inconsistencies can arise that will break the generation. This means if the generation fails, it is usually
best to verify the the application itself is working properly.

To track errors further down, a log file is written to `build/tmp/crnk.gen.typescript.log`. It runs with
`io.crnk` on level `DEBUG` to output a large number of information.
